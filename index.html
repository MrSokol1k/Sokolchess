<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Шахматы">
<meta name="theme-color" content="#1a1008">
  <link rel="apple-touch-icon" href="icon.png">
<title>Шахматы</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<style>
  :root {
    --light: #f0d9b5;
    --dark: #b58863;
    --selected: #f6f669cc;
    --move: #cdd16e99;
    --check: #ff000088;
    --bg: #1a1008;
    --panel: #241810;
    --gold: #c9a84c;
    --gold2: #e8c97a;
    --text: #f0d9b5;
    --board-size: min(96vw, 96vh - 160px);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body {
    background: var(--bg);
    font-family: 'Crimson Text', serif;
    color: var(--text);
    height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden;
    background-image: 
      radial-gradient(ellipse at 20% 20%, #2d1e0a 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, #0a0a1a 0%, transparent 50%);
  }

  header {
    width: 100%;
    text-align: center;
    padding: 12px 16px 8px;
    border-bottom: 1px solid #c9a84c33;
    background: linear-gradient(to bottom, #0d0804, transparent);
  }

  header h1 {
    font-family: 'Cinzel', serif;
    font-size: 22px;
    letter-spacing: 6px;
    color: var(--gold);
    text-transform: uppercase;
  }

  #status-bar {
    font-size: 13px;
    color: #c9a84c99;
    letter-spacing: 2px;
    margin-top: 3px;
    min-height: 18px;
    transition: all 0.3s;
  }

  #status-bar.thinking { color: var(--gold2); animation: pulse 1s infinite; }
  #status-bar.check { color: #ff6b6b; }
  #status-bar.gameover { color: var(--gold2); font-size: 15px; }

  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }

  #board-wrap {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px;
  }

  #board {
    width: var(--board-size);
    height: var(--board-size);
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    border: 2px solid var(--gold);
    box-shadow: 0 0 40px #c9a84c44, 0 0 80px #00000088, inset 0 0 20px #00000044;
    border-radius: 2px;
    overflow: hidden;
    position: relative;
  }

  .cell {
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    transition: background 0.15s;
    user-select: none;
  }

  .cell.light { background: var(--light); }
  .cell.dark { background: var(--dark); }
  .cell.selected { background: var(--selected) !important; }
  .cell.can-move::after {
    content: '';
    width: 28%;
    height: 28%;
    border-radius: 50%;
    background: #00000055;
    position: absolute;
    pointer-events: none;
  }
  .cell.can-capture::after {
    content: '';
    width: 85%;
    height: 85%;
    border-radius: 50%;
    border: 6px solid #00000055;
    position: absolute;
    pointer-events: none;
    background: transparent;
  }
  .cell.in-check { background: var(--check) !important; }

  .piece {
    font-size: calc(var(--board-size) / 9.5);
    line-height: 1;
    pointer-events: none;
    transition: transform 0.15s;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));
    will-change: transform;
  }

  .cell.selected .piece { transform: scale(1.1); }

  .coord-row, .coord-file {
    position: absolute;
    font-family: 'Cinzel', serif;
    font-size: 9px;
    color: #00000055;
    pointer-events: none;
  }
  .coord-row { top: 2px; left: 3px; }
  .coord-file { bottom: 2px; right: 3px; }
  .cell.dark .coord-row, .cell.dark .coord-file { color: #ffffff44; }

  #controls {
    display: flex;
    gap: 10px;
    padding: 10px 16px 16px;
    width: 100%;
    justify-content: center;
  }

  button {
    font-family: 'Cinzel', serif;
    font-size: 12px;
    letter-spacing: 2px;
    padding: 10px 20px;
    border: 1px solid var(--gold);
    background: transparent;
    color: var(--gold);
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
    border-radius: 1px;
  }

  button:active {
    background: var(--gold);
    color: var(--bg);
    transform: scale(0.97);
  }

  #difficulty-wrap {
    display: flex;
    gap: 6px;
    padding: 0 16px 4px;
  }

  .diff-btn {
    font-size: 11px;
    padding: 6px 14px;
    letter-spacing: 1px;
    border-color: #c9a84c55;
    color: #c9a84c88;
  }
  .diff-btn.active {
    border-color: var(--gold);
    color: var(--gold);
    background: #c9a84c11;
  }

  #promotion-modal {
    display: none;
    position: fixed;
    inset: 0;
    background: #000000cc;
    z-index: 100;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 16px;
  }
  #promotion-modal.show { display: flex; }
  #promotion-modal h2 {
    font-family: 'Cinzel', serif;
    color: var(--gold);
    letter-spacing: 3px;
    font-size: 16px;
  }
  #promotion-pieces {
    display: flex;
    gap: 12px;
  }
  .promo-piece {
    font-size: 52px;
    cursor: pointer;
    filter: drop-shadow(0 2px 8px #c9a84c88);
    transition: transform 0.15s;
    padding: 8px;
    border: 1px solid #c9a84c44;
    border-radius: 4px;
    background: var(--panel);
  }
  .promo-piece:active { transform: scale(0.9); }
</style>
</head>
<body>

<header>
  <h1>Chess</h1>
  <div id="status-bar">Ваш ход · Белые</div>
</header>

<div id="difficulty-wrap">
  <button class="diff-btn active" data-level="1">Лёгкий</button>
  <button class="diff-btn" data-level="2">Средний</button>
  <button class="diff-btn" data-level="3">Сложный</button>
</div>

<div id="board-wrap">
  <div id="board"></div>
</div>

<div id="controls">
  <button id="btn-new">Новая игра</button>
  <button id="btn-undo">Отмена хода</button>
</div>

<div id="promotion-modal">
  <h2>Выберите фигуру</h2>
  <div id="promotion-pieces"></div>
</div>

<script>
// ─── PIECES ───────────────────────────────────────────────────────────
const PIECES = {
  wK:'♔', wQ:'♕', wR:'♖', wB:'♗', wN:'♘', wP:'♙',
  bK:'♚', bQ:'♛', bR:'♜', bB:'♝', bN:'♞', bP:'♟'
};
const VALUES = { K:20000, Q:900, R:500, B:330, N:320, P:100 };

// ─── PIECE SQUARE TABLES ──────────────────────────────────────────────
const PST = {
  P: [
     0,  0,  0,  0,  0,  0,  0,  0,
    50, 50, 50, 50, 50, 50, 50, 50,
    10, 10, 20, 30, 30, 20, 10, 10,
     5,  5, 10, 25, 25, 10,  5,  5,
     0,  0,  0, 20, 20,  0,  0,  0,
     5, -5,-10,  0,  0,-10, -5,  5,
     5, 10, 10,-20,-20, 10, 10,  5,
     0,  0,  0,  0,  0,  0,  0,  0
  ],
  N: [
    -50,-40,-30,-30,-30,-30,-40,-50,
    -40,-20,  0,  0,  0,  0,-20,-40,
    -30,  0, 10, 15, 15, 10,  0,-30,
    -30,  5, 15, 20, 20, 15,  5,-30,
    -30,  0, 15, 20, 20, 15,  0,-30,
    -30,  5, 10, 15, 15, 10,  5,-30,
    -40,-20,  0,  5,  5,  0,-20,-40,
    -50,-40,-30,-30,-30,-30,-40,-50
  ],
  B: [
    -20,-10,-10,-10,-10,-10,-10,-20,
    -10,  0,  0,  0,  0,  0,  0,-10,
    -10,  0,  5, 10, 10,  5,  0,-10,
    -10,  5,  5, 10, 10,  5,  5,-10,
    -10,  0, 10, 10, 10, 10,  0,-10,
    -10, 10, 10, 10, 10, 10, 10,-10,
    -10,  5,  0,  0,  0,  0,  5,-10,
    -20,-10,-10,-10,-10,-10,-10,-20
  ],
  R: [
     0,  0,  0,  0,  0,  0,  0,  0,
     5, 10, 10, 10, 10, 10, 10,  5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
     0,  0,  0,  5,  5,  0,  0,  0
  ],
  Q: [
    -20,-10,-10, -5, -5,-10,-10,-20,
    -10,  0,  0,  0,  0,  0,  0,-10,
    -10,  0,  5,  5,  5,  5,  0,-10,
     -5,  0,  5,  5,  5,  5,  0, -5,
      0,  0,  5,  5,  5,  5,  0, -5,
    -10,  5,  5,  5,  5,  5,  0,-10,
    -10,  0,  5,  0,  0,  0,  0,-10,
    -20,-10,-10, -5, -5,-10,-10,-20
  ],
  K: [
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -20,-30,-30,-40,-40,-30,-30,-20,
    -10,-20,-20,-20,-20,-20,-20,-10,
     20, 20,  0,  0,  0,  0, 20, 20,
     20, 30, 10,  0,  0, 10, 30, 20
  ]
};

// ─── GAME STATE ───────────────────────────────────────────────────────
let board, turn, selected, history, enPassant, castling, diffLevel, aiThinking;
let promotionResolve = null;

function initGame() {
  board = Array(64).fill(null);
  const backRank = ['R','N','B','Q','K','B','N','R'];
  for (let i=0;i<8;i++) {
    board[i] = 'b'+backRank[i];
    board[8+i] = 'bP';
    board[48+i] = 'wP';
    board[56+i] = 'w'+backRank[i];
  }
  turn = 'w';
  selected = null;
  history = [];
  enPassant = null;
  castling = { wK:true, wR0:true, wR7:true, bK:true, bR0:true, bR7:true };
  aiThinking = false;
  renderBoard();
  setStatus('Ваш ход · Белые', '');
}

// ─── RENDER ───────────────────────────────────────────────────────────
function renderBoard() {
  const el = document.getElementById('board');
  el.innerHTML = '';
  const inCheck = isInCheck(turn);
  const kingPos = findKing(turn);

  for (let i=0;i<64;i++) {
    const cell = document.createElement('div');
    const row = Math.floor(i/8), col = i%8;
    cell.className = 'cell ' + ((row+col)%2===0 ? 'light':'dark');
    cell.dataset.idx = i;

    if (i===selected) cell.classList.add('selected');
    if (inCheck && i===kingPos) cell.classList.add('in-check');

    if (selected !== null && selected !== i) {
      const moves = getLegalMoves(selected);
      if (moves.includes(i)) {
        cell.classList.add(board[i] ? 'can-capture':'can-move');
      }
    }

    if (board[i]) {
      const p = document.createElement('span');
      p.className = 'piece';
      p.textContent = PIECES[board[i]];
      cell.appendChild(p);
    }

    // coords
    if (col===0) { const c=document.createElement('span'); c.className='coord-row'; c.textContent=8-row; cell.appendChild(c); }
    if (row===7) { const c=document.createElement('span'); c.className='coord-file'; c.textContent='abcdefgh'[col]; cell.appendChild(c); }

    cell.addEventListener('click', () => onCellClick(i));
    el.appendChild(cell);
  }
}

// ─── INPUT ────────────────────────────────────────────────────────────
async function onCellClick(idx) {
  if (aiThinking || turn !== 'w') return;
  if (promotionResolve) return;

  const piece = board[idx];

  if (selected === null) {
    if (piece && piece[0] === 'w') {
      selected = idx;
      renderBoard();
    }
    return;
  }

  if (idx === selected) {
    selected = null;
    renderBoard();
    return;
  }

  const moves = getLegalMoves(selected);
  if (moves.includes(idx)) {
    await makeMove(selected, idx, 'w');
    selected = null;
    if (turn === 'b') {
      renderBoard();
      setStatus('Компьютер думает...', 'thinking');
      await sleep(50);
      await aiMove();
    }
  } else if (piece && piece[0] === 'w') {
    selected = idx;
    renderBoard();
  } else {
    selected = null;
    renderBoard();
  }
}

// ─── MAKE MOVE ────────────────────────────────────────────────────────
async function makeMove(from, to, color) {
  const piece = board[from];
  const type = piece[1];
  const snapshot = {
    board: [...board], enPassant, castling: {...castling},
    from, to, piece
  };
  history.push(snapshot);

  // En passant capture
  if (type==='P' && to===enPassant) {
    const dir = color==='w' ? 8 : -8;
    board[to+dir] = null;
  }
  enPassant = null;

  // Pawn double push → set en passant
  if (type==='P') {
    const diff = Math.abs(to-from);
    if (diff===16) enPassant = color==='w' ? from-8 : from+8;
  }

  // Castling move
  if (type==='K') {
    if (from===60 && to===62) { board[63]=null; board[61]='wR'; } // white king side
    if (from===60 && to===58) { board[56]=null; board[59]='wR'; } // white queen side
    if (from===4 && to===6)   { board[7]=null;  board[5]='bR'; }  // black king side
    if (from===4 && to===2)   { board[0]=null;  board[3]='bR'; }  // black queen side
    castling[color+'K'] = false;
  }
  if (type==='R') {
    if (from===56) castling.wR0=false;
    if (from===63) castling.wR7=false;
    if (from===0)  castling.bR0=false;
    if (from===7)  castling.bR7=false;
  }

  board[to] = board[from];
  board[from] = null;

  // Promotion
  if (type==='P' && (to<8 || to>=56)) {
    let choice;
    if (color==='w') {
      choice = await askPromotion(color);
    } else {
      choice = 'Q'; // AI always promotes to queen
    }
    board[to] = color+choice;
  }

  turn = color==='w' ? 'b' : 'w';
  checkGameOver();
}

function undoMove() {
  if (aiThinking) return;
  // Undo two moves (player + AI)
  let count = history.length >= 2 ? 2 : history.length;
  for (let i=0;i<count;i++) {
    const snap = history.pop();
    if (!snap) break;
    board = snap.board;
    enPassant = snap.enPassant;
    castling = snap.castling;
    turn = snap.piece[0]==='w' ? 'w' : 'b';
  }
  turn = 'w';
  selected = null;
  renderBoard();
  setStatus('Ваш ход · Белые', '');
}

// ─── PROMOTION ────────────────────────────────────────────────────────
function askPromotion(color) {
  return new Promise(resolve => {
    promotionResolve = resolve;
    const modal = document.getElementById('promotion-modal');
    const container = document.getElementById('promotion-pieces');
    container.innerHTML = '';
    const options = ['Q','R','B','N'];
    options.forEach(t => {
      const btn = document.createElement('div');
      btn.className = 'promo-piece';
      btn.textContent = PIECES[color+t];
      btn.onclick = () => {
        modal.classList.remove('show');
        promotionResolve = null;
        resolve(t);
      };
      container.appendChild(btn);
    });
    modal.classList.add('show');
  });
}

// ─── GAME OVER ────────────────────────────────────────────────────────
function checkGameOver() {
  const moves = getAllLegalMoves(turn);
  if (moves.length === 0) {
    if (isInCheck(turn)) {
      const winner = turn==='w' ? 'Чёрные победили' : 'Вы победили!';
      setStatus('Мат · ' + winner, 'gameover');
    } else {
      setStatus('Пат · Ничья', 'gameover');
    }
    turn = null;
    renderBoard();
    return true;
  }
  if (isInCheck(turn)) {
    setStatus(turn==='w' ? 'Шах! Ваш ход' : 'Шах!', 'check');
  } else {
    setStatus(turn==='w' ? 'Ваш ход · Белые' : 'Ваш ход...', '');
  }
  return false;
}

// ─── MOVE GENERATION ─────────────────────────────────────────────────
function getLegalMoves(from) {
  const pseudo = getPseudoMoves(from, board, enPassant, castling);
  return pseudo.filter(to => {
    const nb = [...board];
    const piece = nb[from];
    const type = piece[1];
    const color = piece[0];
    let ep = enPassant;
    if (type==='P' && to===ep) { nb[to+(color==='w'?8:-8)] = null; }
    if (type==='K') {
      if (from===60&&to===62) { nb[63]=null; nb[61]='wR'; }
      if (from===60&&to===58) { nb[56]=null; nb[59]='wR'; }
      if (from===4&&to===6)   { nb[7]=null;  nb[5]='bR'; }
      if (from===4&&to===2)   { nb[0]=null;  nb[3]='bR'; }
    }
    nb[to]=nb[from]; nb[from]=null;
    return !isInCheckBoard(color, nb);
  });
}

function getAllLegalMoves(color) {
  const result = [];
  for (let i=0;i<64;i++) {
    if (board[i] && board[i][0]===color) {
      const moves = getLegalMoves(i);
      moves.forEach(to => result.push([i,to]));
    }
  }
  return result;
}

function getPseudoMoves(from, brd, ep, cas) {
  const piece = brd[from];
  if (!piece) return [];
  const color = piece[0], type = piece[1];
  const opp = color==='w'?'b':'w';
  const moves = [];
  const row = Math.floor(from/8), col = from%8;

  const add = (to) => {
    if (to<0||to>63) return;
    if (brd[to] && brd[to][0]===color) return;
    moves.push(to);
  };
  const slide = (dr, dc) => {
    let r=row+dr, c=col+dc;
    while(r>=0&&r<8&&c>=0&&c<8) {
      const idx=r*8+c;
      if (brd[idx]) { if(brd[idx][0]===opp) moves.push(idx); break; }
      moves.push(idx); r+=dr; c+=dc;
    }
  };

  if (type==='P') {
    const dir = color==='w'?-1:1;
    const startRow = color==='w'?6:1;
    const fwd = from+dir*8;
    if (fwd>=0&&fwd<64&&!brd[fwd]) {
      moves.push(fwd);
      if (row===startRow && !brd[from+dir*16]) moves.push(from+dir*16);
    }
    [-1,1].forEach(dc => {
      const tc = col+dc;
      if (tc<0||tc>7) return;
      const to = fwd-(8-8) + (dir*8-(row+dir)*8+from+dir*8-fwd) + dc; // simplified
      const t2 = (row+dir)*8+(col+dc);
      if (t2>=0&&t2<64) {
        if (brd[t2]&&brd[t2][0]===opp) moves.push(t2);
        if (t2===ep) moves.push(t2);
      }
    });
  }
  else if (type==='N') {
    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr,dc])=>{
      const r2=row+dr,c2=col+dc;
      if(r2>=0&&r2<8&&c2>=0&&c2<8) add(r2*8+c2);
    });
  }
  else if (type==='B') { [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr,dc])=>slide(dr,dc)); }
  else if (type==='R') { [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc])=>slide(dr,dc)); }
  else if (type==='Q') { [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc])=>slide(dr,dc)); }
  else if (type==='K') {
    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dr,dc])=>{
      const r2=row+dr,c2=col+dc;
      if(r2>=0&&r2<8&&c2>=0&&c2<8) add(r2*8+c2);
    });
    // Castling
    if (color==='w'&&from===60) {
      if (cas.wK&&cas.wR7&&!brd[61]&&!brd[62]&&!isSquareAttacked(60,'w',brd)&&!isSquareAttacked(61,'w',brd)&&!isSquareAttacked(62,'w',brd)) moves.push(62);
      if (cas.wK&&cas.wR0&&!brd[59]&&!brd[58]&&!brd[57]&&!isSquareAttacked(60,'w',brd)&&!isSquareAttacked(59,'w',brd)&&!isSquareAttacked(58,'w',brd)) moves.push(58);
    }
    if (color==='b'&&from===4) {
      if (cas.bK&&cas.bR7&&!brd[5]&&!brd[6]&&!isSquareAttacked(4,'b',brd)&&!isSquareAttacked(5,'b',brd)&&!isSquareAttacked(6,'b',brd)) moves.push(6);
      if (cas.bK&&cas.bR0&&!brd[1]&&!brd[2]&&!brd[3]&&!isSquareAttacked(4,'b',brd)&&!isSquareAttacked(3,'b',brd)&&!isSquareAttacked(2,'b',brd)) moves.push(2);
    }
  }
  return moves;
}

function isSquareAttacked(sq, color, brd) {
  const opp = color==='w'?'b':'w';
  for (let i=0;i<64;i++) {
    if (!brd[i]||brd[i][0]!==opp) continue;
    const pm = getPseudoMovesSimple(i, brd);
    if (pm.includes(sq)) return true;
  }
  return false;
}

function getPseudoMovesSimple(from, brd) {
  // Like getPseudoMoves but without castling/ep to avoid recursion
  const piece = brd[from];
  if (!piece) return [];
  const color = piece[0], type = piece[1];
  const opp = color==='w'?'b':'w';
  const moves = [];
  const row = Math.floor(from/8), col = from%8;

  const add = (to) => {
    if (to<0||to>63) return;
    if (brd[to]&&brd[to][0]===color) return;
    moves.push(to);
  };
  const slide = (dr, dc) => {
    let r=row+dr, c=col+dc;
    while(r>=0&&r<8&&c>=0&&c<8) {
      const idx=r*8+c;
      if (brd[idx]) { if(brd[idx][0]===opp) moves.push(idx); break; }
      moves.push(idx); r+=dr; c+=dc;
    }
  };

  if (type==='P') {
    const dir = color==='w'?-1:1;
    [-1,1].forEach(dc=>{
      const tc=col+dc; if(tc<0||tc>7) return;
      const t2=(row+dir)*8+(col+dc);
      if(t2>=0&&t2<64) moves.push(t2);
    });
  }
  else if (type==='N') {
    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr,dc])=>{
      const r2=row+dr,c2=col+dc;
      if(r2>=0&&r2<8&&c2>=0&&c2<8) add(r2*8+c2);
    });
  }
  else if (type==='B') { [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr,dc])=>slide(dr,dc)); }
  else if (type==='R') { [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc])=>slide(dr,dc)); }
  else if (type==='Q') { [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc])=>slide(dr,dc)); }
  else if (type==='K') {
    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dr,dc])=>{
      const r2=row+dr,c2=col+dc;
      if(r2>=0&&r2<8&&c2>=0&&c2<8) add(r2*8+c2);
    });
  }
  return moves;
}

function findKing(color) {
  return board.findIndex(p => p===color+'K');
}

function isInCheck(color) { return isInCheckBoard(color, board); }

function isInCheckBoard(color, brd) {
  const kingIdx = brd.findIndex(p => p===color+'K');
  if (kingIdx===-1) return true;
  return isSquareAttacked(kingIdx, color, brd);
}

// ─── AI ───────────────────────────────────────────────────────────────
async function aiMove() {
  aiThinking = true;
  await sleep(10);
  
  const depth = [1,2,3][diffLevel-1];
  const [from, to] = getBestMove(depth);
  
  if (from !== undefined) {
    await makeMove(from, to, 'b');
  }
  aiThinking = false;
  renderBoard();
  if (turn==='w') setStatus(isInCheck('w') ? 'Шах! Ваш ход':'Ваш ход · Белые', isInCheck('w')?'check':'');
}

function getBestMove(depth) {
  const moves = getAllLegalMovesFor('b');
  if (!moves.length) return [];
  
  let best = -Infinity, bestMove = moves[0];
  for (const [from,to] of moves) {
    const snap = applyMoveTemp(from, to, 'b');
    const score = -minimax(depth-1, -Infinity, Infinity, 'w');
    undoMoveTemp(snap);
    if (score > best) { best=score; bestMove=[from,to]; }
  }
  return bestMove;
}

function minimax(depth, alpha, beta, color) {
  if (depth===0) return evaluate();
  const moves = getAllLegalMovesFor(color);
  if (!moves.length) {
    if (isInCheckBoard(color, board)) return color==='b' ? -19000 : 19000;
    return 0;
  }
  const sign = color==='b' ? 1 : -1;
  let best = -Infinity;
  for (const [from,to] of moves) {
    const snap = applyMoveTemp(from, to, color);
    const score = sign * (-minimax(depth-1, -beta, -alpha, color==='w'?'b':'w'));
    undoMoveTemp(snap);
    best = Math.max(best, score);
    alpha = Math.max(alpha, score);
    if (alpha >= beta) break;
  }
  return best * sign;
}

let tempEP = null, tempCastling = null;
function applyMoveTemp(from, to, color) {
  const snap = { board:[...board], enPassant, castling:{...castling} };
  tempEP = enPassant; tempCastling = castling;
  const piece = board[from];
  const type = piece[1];
  if (type==='P'&&to===enPassant) { board[to+(color==='w'?8:-8)]=null; }
  enPassant = null;
  if (type==='P'&&Math.abs(to-from)===16) enPassant=color==='w'?from-8:from+8;
  if (type==='K') {
    if(from===60&&to===62){board[63]=null;board[61]='wR';}
    if(from===60&&to===58){board[56]=null;board[59]='wR';}
    if(from===4&&to===6){board[7]=null;board[5]='bR';}
    if(from===4&&to===2){board[0]=null;board[3]='bR';}
    castling[color+'K']=false;
  }
  if(type==='R'){
    if(from===56)castling.wR0=false;
    if(from===63)castling.wR7=false;
    if(from===0)castling.bR0=false;
    if(from===7)castling.bR7=false;
  }
  board[to]=board[from]; board[from]=null;
  if(type==='P'&&(to<8||to>=56)) board[to]=color+'Q';
  return snap;
}

function undoMoveTemp(snap) {
  board = snap.board;
  enPassant = snap.enPassant;
  castling = snap.castling;
}

function getAllLegalMovesFor(color) {
  const result = [];
  for (let i=0;i<64;i++) {
    if (board[i]&&board[i][0]===color) {
      getPseudoMoves(i, board, enPassant, castling).forEach(to => {
        const nb=[...board];
        const p=nb[i], t=p[1], c=p[0];
        if(t==='P'&&to===enPassant){nb[to+(c==='w'?8:-8)]=null;}
        if(t==='K'){
          if(i===60&&to===62){nb[63]=null;nb[61]='wR';}
          if(i===60&&to===58){nb[56]=null;nb[59]='wR';}
          if(i===4&&to===6){nb[7]=null;nb[5]='bR';}
          if(i===4&&to===2){nb[0]=null;nb[3]='bR';}
        }
        nb[to]=nb[i];nb[i]=null;
        if(!isInCheckBoard(color,nb)) result.push([i,to]);
      });
    }
  }
  return result;
}

function evaluate() {
  let score = 0;
  for (let i=0;i<64;i++) {
    const p = board[i];
    if (!p) continue;
    const color=p[0], type=p[1];
    const val = VALUES[type]||0;
    const row=Math.floor(i/8);
    const pstIdx = color==='w' ? i : (7-row)*8+(i%8);
    const pst = (PST[type]||[])[pstIdx]||0;
    score += (color==='b'?1:-1) * (val+pst);
  }
  return score;
}

// ─── HELPERS ──────────────────────────────────────────────────────────
function sleep(ms) { return new Promise(r=>setTimeout(r,ms)); }

function setStatus(text, cls) {
  const el = document.getElementById('status-bar');
  el.textContent = text;
  el.className = cls || '';
}

// ─── CONTROLS ─────────────────────────────────────────────────────────
document.getElementById('btn-new').addEventListener('click', initGame);
document.getElementById('btn-undo').addEventListener('click', undoMove);

document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.diff-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    diffLevel = parseInt(btn.dataset.level);
  });
});

diffLevel = 1;
initGame();
</script>
</body>
</html>
